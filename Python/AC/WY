给定一个字符串，请你将字符串重新编码，将连续的字符替换成“连续出现的个数+字符”。比如字符串AAAABCCDAA会被编码成4A1B2C1D2A。 
每个测试输入包含1个测试用例
每个测试用例输入只有一行字符串，字符串只包括大写英文字母，长度不超过10000。
intput:AAAABCCDAA
out:4A1B2C1D2A


在一个N*N的数组中寻找所有横，竖，左上到右下，右上到左下，四种方向的直线连续D个数字的和里面最大的值 
	每个测试输入包含1个测试用例，第一行包括两个整数 N 和 D :
	3 <= N <= 100
	1 <= D <= N
	接下来有N行，每行N个数字d:
	0 <= d <= 100
输出一个整数，表示找到的和的最大值
intput:
4 2
87 98 79 61
10 27 95 70
20 64 73 29
71 65 15 0
out:193


大家一定玩过“推箱子”这个经典的游戏。具体规则就是在一个N*M的地图上，有1个玩家、1个箱子、1个目的地以及若干障碍，其余是空地。玩家可以往上下左右4个方向移动，但是不能移动出地图或者移动到障碍里去。如果往这个方向移动推到了箱子，箱子也会按这个方向移动一格，当然，箱子也不能被推出地图或推到障碍里。当箱子被推到目的地以后，游戏目标达成。现在告诉你游戏开始是初始的地图布局，请你求出玩家最少需要移动多少步才能够将游戏目标达成。
每个测试输入包含1个测试用例
第一行输入两个数字N，M表示地图的大小。其中0<N，M<=8。
接下来有N行，每行包含M个字符表示该行地图。其中 . 表示空地、X表示玩家、*表示箱子、#表示障碍、@表示目的地。
每个地图必定包含1个玩家、1个箱子、1个目的地
输出一个数字表示玩家最少需要移动多少步才能将游戏目标达成。当无论如何达成不了的时候，输出-1。
input:
4 4
....
..*@
....
.X..
6 6
...#..
......
#*##..
..##.#
..X...
.@#...
output:
3
11


在一条无限长的跑道上，有N匹马在不同的位置上出发开始赛马。当开始赛马比赛后，所有的马开始以自己的速度一直匀速前进。每匹马的速度都不一样，且全部是同样的均匀随机分布。在比赛中当某匹马追上了前面的某匹马时，被追上的马就出局。 请问按以上的规则比赛无限长的时间后，赛道上剩余的马匹数量的数学期望是多少 
每个测试输入包含1个测试用例
输入只有一行，一个正整数N
1 <= N <= 1000
输出一个浮点数，精确到小数点后四位数字，表示剩余马匹数量的数学期望
input:
1
2 
output:
1.0000
1.5000


洗牌在生活中十分常见，现在需要写一个程序模拟洗牌的过程。 现在需要洗2n张牌，从上到下依次是第1张，第2张，第3张一直到第2n张。首先，我们把这2n张牌分成两堆，左手拿着第1张到第n张（上半堆），右手拿着第n+1张到第2n张（下半堆）。接着就开始洗牌的过程，先放下右手的最后一张牌，再放下左手的最后一张牌，接着放下右手的倒数第二张牌，再放下左手的倒数第二张牌，直到最后放下左手的第一张牌。接着把牌合并起来就可以了。 例如有6张牌，最开始牌的序列是1,2,3,4,5,6。首先分成两组，左手拿着1,2,3；右手拿着4,5,6。在洗牌过程中按顺序放下了6,3,5,2,4,1。把这六张牌再次合成一组牌之后，我们按照从上往下的顺序看这组牌，就变成了序列1,4,2,5,3,6。 现在给出一个原始牌组，请输出这副牌洗牌k次之后从上往下的序列。 
输入描述:
第一行一个数T(T ≤ 100)，表示数据组数。对于每组数据，第一行两个数n,k(1 ≤ n,k ≤ 100)，接下来一行有2n个数a1,a2,...,a2n(1 ≤ ai ≤ 1000000000)。表示原始牌组从上到下的序列。


输出描述:
对于每组数据，输出一行，最终的序列。数字之间用空格隔开，不要在行末输出多余的空格。
input:
3
3 1
1 2 3 4 5 6
3 2
1 2 3 4 5 6
2 2
1 1 1 1
output:
1 4 2 5 3 6
1 5 4 3 2 6
1 1 1 1


有 n 个学生站成一排，每个学生有一个能力值，牛牛想从这 n 个学生中按照顺序选取 k 名学生，要求相邻两个学生的位置编号的差不超过 d，使得这 k 个学生的能力值的乘积最大，你能返回最大的乘积吗？ 
输入描述:
每个输入包含 1 个测试用例。每个测试数据的第一行包含一个整数 n (1 <= n <= 50)，表示学生的个数，接下来的一行，包含 n 个整数，按顺序表示每个学生的能力值 ai（-50 <= ai <= 50）。接下来的一行包含两个整数，k 和 d (1 <= k <= 10, 1 <= d <= 50)。


输出描述:
输出一行表示最大的乘积。
input:
3
7 4 7
2 50
output:
49

###############################################
题目

如果一个数字序列逆置之后跟原序列是一样的就称这样的数字序列为回文序列。例如： 
{1, 2, 1}, {15, 78, 78, 15} , {112} 是回文序列, 
{1, 2, 2}, {15, 78, 87, 51} ,{112, 2, 11} 不是回文序列。 
现在给出一个数字序列，允许使用一种转换操作： 
选择任意两个相邻的数，然后从序列移除这两个数，并用这两个数字的和插入到这两个数之前的位置(只插入一个和)。 
现在对于所给序列要求出最少需要多少次操作可以将其变成回文序列。

输入描述:

输入为两行，第一行为序列长度n ( 1 ≤ n ≤ 50) 
第二行为序列中的n个整数item[i] (1 ≤ iteam[i] ≤ 1000)，以空格分隔。

输出描述:

输出一个数，表示最少需要的转换次数

输入例子:

4 
1 1 1 3

输出例子:

2
#这种方法根据回文的特性去处理
#1.判断列表第0个和列表最后一个是否相等
#   若相等,可去掉list[0]和list[last]做简化出来
#   若不相等,要形成回文的话,一定要使得list[0]==list[last]为True
#       当list[0]>list[last]时,对list进行逆序,这样方便以后只要对list[0]和list[1]处理
#       这样来回的对list[0]和list[last]操作,最后list[0]=list[last]
def dealHuiwen(li,count=0):
    leng = len(li)
    if leng>1:
        last=leng-1
        if li[0]==li[last]:
            del li[0]
            del li[last-1]#此时li[last]在li[last-1]的位置
            count = dealHuiwen(li,count)#简化后,再进行递归处理
        else:
            if li[0]>li[last]:
                li.reverse()#逆序,总是将最小的放在最前
            li[0]=li[0]+li[1]
            del li[1]
            count+=1
            count=dealHuiwen(li,count)    
    return count


#################################################

num=input()      #输入数据,在python2.x中用raw_input()
string=input()   #输入数据,在python2.x中用raw_input()
li=string.split(' ')
for i in range(0,int(num)):
    li[i]=int(li[i])#转化为Int
print(dealHuiwen(li))
###############################################
小易有一个圆心在坐标原点的圆，小易知道圆的半径的平方。小易认为在圆上的点而且横纵坐标都是整数的点是优雅的，小易现在想寻找一个算法计算出优雅的点的个数，请你来帮帮他。
例如：半径的平方如果为25
优雅的点就有：(+/-3, +/-4), (+/-4, +/-3), (0, +/-5) (+/-5, 0)，一共12个点。 
输入描述:
输入为一个整数，即为圆半径的平方,范围在32位int范围内。


输出描述:
输出为一个整数，即为优雅的点的个数

输入例子:
25

输出例子:
12
def count(n):
	sum=0
	s=int(pow(n,1.0/2.0))
	i=0
	j=0
	while(i<=s):
		j = int(pow(n-i*i,1.0/2.0))
		if i>j: break
		if (i*i+j*j)==n:
			if (i == 0) or (i==j):
				sum += 4
			else:
				sum += 8
		i+=1
	return sum

n = input()
print count(n)

###############################################

小易来到了一条石板路前，每块石板上从1挨着编号为：1、2、3.......
这条石板路要根据特殊的规则才能前进：对于小易当前所在的编号为K的 石板，小易单次只能往前跳K的一个约数(不含1和K)步，即跳到K+X(X为K的一个非1和本身的约数)的位置。 小易当前处在编号为N的石板，他想跳到编号恰好为M的石板去，小易想知道最少需要跳跃几次可以到达。
例如：
N = 4，M = 24：
4->6->8->12->18->24
于是小易最少需要跳跃5次，就可以从4号石板跳到24号石板 
输入描述:
输入为一行，有两个整数N，M，以空格隔开。
(4 ≤ N ≤ 100000)
(N ≤ M ≤ 100000)
输出描述:
输出小易最少需要跳跃的步数,如果不能到达输出-1
输入例子:
4 24
输出例子:
5

class MiGong:
    def __init__(self, i, di, di_len,j):
        self.i = i#当前位置
        self.di_len = di_len#约数长度
        self.di = di#所有约数
        self.j = j#所在的约数的位置

def Find(N,M):
    top_find = int(N**0.5)+1
    res=[]
    for i in range(2,top_find):
        if ((N % i)== 0) & ((N+i)<=M):
            res.append(int(i))
        if (i * i != N) & (N % (N / i) == 0) & ((N+int(N / i))<=M):
            res.append(int(N / i))
    res = list(set(res))
    res_len = len(res)
    return res,res_len
            
def MgPath(start,end):#start:N -> M
    ii=0
    dii=0
    dii_len=0
    jj=0
    temp_ii=0
    temp_i=0
    all_path = []#所有路径
    path_min = []#最短路径
    minlen = float('inf')#最短路径长度\\
    count = 0
    top = 0
    mg = [0]*(end+1)
    ####头结点
    di,di_len = Find(start,end)
    sentence = 'a'+repr(top)+'=MiGong('+repr(start)+','+repr(di)+','+repr(di_len)+',-1)'
    exec(sentence)
    mg[N] = -1
    while(top>-1):#栈不空时循环
        exec('ii='+'a'+repr(top)+'.i')#所在位置
        exec('dii='+'a'+repr(top)+'.di')#当前位置所有约数
        exec('dii_len='+'a'+repr(top)+'.di_len')
        exec('jj='+'a'+repr(top)+'.j')#已经遍历的约数
        if ii>end:
            return 0
        if ii==end:#找到了出口
            temp_path = []
            for k in range(top+1):
                exec('temp_i = '+'a'+repr(k)+'.i')
                temp_path.append(temp_i)
            all_path.append(temp_path)
            count+=1
            if (top+1)<minlen:#比较输出最短路径
                path_min = temp_path[:]
                minlen = len(path_min)
            
            #让该位置变为其他路径的可走结点
            exec('temp_ii ='+ 'a'+repr(top)+'.i')
            mg[temp_ii] = 0
            top-=1
            exec('ii='+'a'+repr(top)+'.i')
            exec('jj='+'a'+repr(top)+'.j')
            exec('dii_len='+'a'+repr(top)+'.di_len')
            exec('dii='+'a'+repr(top)+'.di')
            
        find = 0
        while (jj<(dii_len-1)) & (find==0):#找下一个可走结点
            jj+=1
            exec('temp_ii='+'a'+repr(top)+'.i+'+repr(dii[jj]))
            if mg[temp_ii]==0:
                find=1
                
        if find == 1:#找到了下一个可走结点
            exec('a'+repr(top)+'.j'+'=jj')#修改原栈顶元素的di值
            top+=1#下一个可走结点进栈
            exec('a'+repr(top)+'=MiGong('+repr(start)+','+repr(di)+','+repr(di_len)+',-1)')#初始化实例
            exec('a'+repr(top)+'.i'+'=temp_ii')
            di,di_len = Find(temp_ii,end)
            exec('a'+repr(top)+'.di'+'=di')
            exec('a'+repr(top)+'.di_len'+'=di_len')
            exec('a'+repr(top)+'.jj'+'=-1')
            mg[temp_ii] = -1
        else:
            exec('temp_ii ='+ 'a'+repr(top)+'.i')
            if temp_ii>end:
                return 0
            mg[temp_ii] = 0
            top-=1
    #print path_min
    return minlen

import sys
num = sys.stdin.readline().strip()
while num:
    N,M = map(lambda x:int(x),num.split(" "))
    print MgPath(N,M)-1
    num = sys.stdin.readline().strip()

################################################
现在有n位工程师和6项工作(编号为0至5)，现在给出每个人能够胜任的工作序号表(用一个字符串表示，比如：045，表示某位工程师能够胜任0号，4号，5号工作)。现在需要进行工作安排，每位工程师只能被安排到自己能够胜任的工作当中去，两位工程师不能安排到同一项工作当中去。如果两种工作安排中有一个人被安排在的工作序号不一样就被视为不同的工作安排，现在需要计算出有多少种不同工作安排计划。 
输入描述:
输入数据有n+1行：
第一行为工程师人数n(1 ≤ n ≤ 6)
接下来的n行，每行一个字符串表示第i(1 ≤ i ≤ n)个人能够胜任的工作(字符串不一定等长的)
输出描述:
输出一个整数，表示有多少种不同的工作安排方案
输入例子:
6
012345
012345
012345
012345
012345
012345

from copy import deepcopy
def Initialize(can_do,N,end):#初始化数据格式
    all_job = {}
    one_job = {}
    for i in range(N):#统计
        for j in range(len(can_do[i])):
            one_job[can_do[i][j]] = one_job.get(can_do[i][j],"") + repr(i)
    for i in range(end):#整理数据格式
        temp = {}
        temp['who'] = '0'
        temp['di'] = one_job[repr(i)]
        temp['di_len'] = len(one_job[repr(i)])
        temp['j'] = -1
        all_job[repr(i)] = temp
    return all_job
    
def Arrange_job(raw_job,end):
    count = 0#计数
    ####安排第一个工作
    for gg in range(len(raw_job)):
        if '0' in raw_job[repr(gg)]['di']:
            all_job = deepcopy(raw_job)
            ###########################使得安排的是第一个工作
            all_job[repr(0)] = deepcopy(raw_job[repr(gg)])
            all_job[repr(gg)] = deepcopy(raw_job[repr(0)])
            top = 0#指针
            mg = [0]*N#工程师排位码
            mg[gg] = -1
            ##########
            while(top>-1):#栈不空时循环
                dii_len = all_job[repr(top)]['di_len']#可用工程师数量
                jj = all_job[repr(top)]['j']#已用
                if top==(end-1):#安排完毕
                    count+=1#计数
                    #让该工程师变为其他工作可用
                    temp_i = all_job[repr(top)]['who']
                    mg[int(temp_i)] = 0
                    top-=1
                    dii_len = all_job[repr(top)]['di_len']
                    jj = all_job[repr(top)]['j']#已遍历工程师
                find = 0
                while (jj<(dii_len-1)) & (find==0):#找下一个可用工程师
                    jj+=1
                    temp_i = all_job[repr(top)]['di'][jj]
                    if mg[int(temp_i)]==0:
                        find=1 
                if find == 1:#找到了下一个可走结点
                    all_job[repr(top)]['j'] = jj#修改原栈顶元素的j值
                    top+=1#下一个可走结点进栈
                    all_job[repr(top)]['who'] = temp_i
                    mg[int(temp_i)] = -1
                    all_job[repr(top)]['j'] = -1
                else:
                    temp_i = all_job[repr(top)]['who']
                    mg[int(temp_i)] = 0
                    top-=1
    return count
    
import sys
N = sys.stdin.readline().strip()
while N:
    N = int(N)
    end=6
    can_do = []
    for i in range(N):
        one_do = sys.stdin.readline().strip()
        can_do.append(one_do)
    raw_job = Initialize(can_do,N,end)
    pritn Arrange_job(raw_job,end)
    N = sys.stdin.readline().strip()


一种双核CPU的两个核能够同时的处理任务，现在有n个已知数据量的任务需要交给CPU处理，假设已知CPU的每个核1秒可以处理1kb，每个核同时只能处理一项任务。n个任务可以按照任意顺序放入CPU进行处理，现在需要设计一个方案让CPU处理完这批任务所需的时间最少，求这个最小的时间。 
输入描述:
输入包括两行：
第一行为整数n(1 ≤ n ≤ 50)
第二行为n个整数length[i](1024 ≤ length[i] ≤ 4194304)，表示每个任务的长度为length[i]kb，每个数均为1024的倍数。


输出描述:
输出一个整数，表示最少需要处理的时间

输入例子:
5
3072 3072 7168 3072 1024

输出例子:
9216