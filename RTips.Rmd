---
title: "RTips"
author: "jsysley"
date: "2016年9月18日"
output: html_document
---

#三个数据集：<br>
```{r}
#自带数据集
str(women)
str(uspop)
str(Titanic)
```

---

##names(),class(),head(),tail()
```{r}
library(MASS)
data("Insurance")#获取数据集
str(Insurance)#查看数据集
names(Insurance)#查看数据集的变量名字
head(names(Insurance),n=2)#仅列出前面两个变量名字
tail(names(Insurance),n=2)#仅列出后面两个变量名字
head(Insurance$Holders,n=2)#仅列出前面两个数据
```

---

###通过系列函数as.numeric(),as.integer(),as.logical(),as.character()
强制数据转换

---

###通过系列函数is.numeric(),is.integer(),is.logical(),is.character()来判断数据类型，返回布尔值

---

#数据抽样
用到base软件包的sample()函数，以及sampling包的strata(),cluster()函数

##简单随机抽样：sample()
sample(x,size,replace=FALSE,prob=NULL)<br>
* 其中x表示带抽取对象，一般用向量表示；size为非负整数，抽取的样本个数，replace表示是否为有放回抽样，prob设置抽取各样本的概率，默认等概率

例如对于一个数据集Insurance，可以如下方式抽样：
```{r}
str(Insurance)
sub1=sample(nrow(Insurance),10,replace = TRUE)#抽取index来获取样本
sub2=Insurance[sub1,]#通过index获取样本
```

下面演示用prob时向量怎么写，最后一条样本概率为1，其他样本概率为0
```{r}
sub3=sample(nrow(Insurance),10,replace = TRUE,prob = c(rep(0,nrow(Insurance)-1),1))#prob的向量长度要注意

sub4=Insurance[sub3,]#抽取数据
```

---

##分层抽样：strata()
strata(data,stratanames=NULL,size,method=c("srswor","srswr","poission","systematic",pik,description=FALSE))
* 其中，data为待抽数据集；stratanames中为分层所依据的变量名称；size为抽取的各层的样本数（顺序与数据集改变量的水平出现顺序一致；method为抽样方法，分别为无放回，有放回，泊松，系统抽样，默认srswor；pik设置各层中各样本的概率；description选择是否输出含有各层基本信息的结果）

下面对数据集Insurance按照District变量为分层变量来抽样，1-4个街区分别抽取1-4个样本

```{r}
library(sampling)
sub5=strata(Insurance,stratanames="District",size=c(1,2,3,4),method="srswor")
sub5
#其中第一列为样本所在数据集的行号，最后一列为所在层数，Prob为所在层数的抽样概率
#通过getdata()函数获取分层抽样的数据
getdata(Insurance,sub5)
```

---

##整群抽样：cluster()
cluster(data,clustername,size,method=c("srswor","srswr","poisson","systematic"),pik,description=FALSE)
* 其中，data为待抽数据集；size为抽取的样本数；method为抽样方法，分别为无放回，有放回，泊松，系统抽样，默认srswor；pik设置各层中各样本的概率；description选择是否输出含有各层基本信息的结果）；clustername指定用来划分群的变量名称

```{r}
str(Insurance)
#共抽取2个整群，所含样本数为32个
sub6=cluster(Insurance,clustername = "District",size = 2,method = "srswor",description = TRUE)
#显示抽样结果,抽中的District取值为2，3的两个整群，共四个群，每个群抽中的概率0.5
sub6
#拿到数据
getdata(Insurance,sub6)
```

---

##划分训练集与测试集
以Insurance数据集为例，无放回方式抽取3/4的样本作为训练集，剩下1/4为测试集

```{r}
train_sub=sample(nrow(Insurance),3/4*nrow(Insurance))#抽取行号
train_data=Insurance[train_sub,]#拿取数据作为训练集
test_data=Insurance[-train_sub,]#拿取剩下的数据作为测试集
```


#探索性数据分析

用到Hmisc()包：describe()

fBasics包的basicStats()

timeDate包的skewness(),kurtosis()

##变量概况
```{r}
attributes(Insurance)#查看数据属性列表
str(Insurance)#查看数据集结构
names(Insurance)#列出数据集的各个变量的名字
summary(Insurance)#查看数据集各变量的一系列统计指标值
```

用Hmisc包的describe()函数查看变量概况，会给出样本总个数(n)，缺失样本数(missing)，水平个数(unique)

```{r}
library(Hmisc)
describe(Insurance)
```

```{r}
library(fBasics)
basicStats(Insurance$Holders)
```

计算峰度和偏度，这两个指标值可以通过basicStats()函数得到，也可以用以下方法得到
```{r}
library(timeDate)
skewness(Insurance[,4:5])#计算偏度
kurtosis(Insurance[,4:5])#计算峰度
```

###稀疏性
用Matrix包来探究，为R中最著名的稀疏矩阵包，其提供的函数主要用于处理高密度矩阵或者稀疏矩阵

下面生产一个10*10的数据矩阵，100个元素，只有10个元素随机取1
```{r}
library(Matrix)
i=sample(1:10,10,replace=TRUE)#在1到10有放回取10个数，作为数据集中非空元素的行号
j=sample(1:10,10,replace=TRUE)#在1到10中有放回的取10个数，作为数据集中非空元素的列号
(A=sparseMatrix(i,j,x=1))#对i行j列的元素取值1，其余为空,生成稀疏矩阵A
```

###缺失值观察
用mice包的md.pattern()函数来获取其中的缺失值得分布情况

```{r}
library(mice)
a=rep(1,10)
a[2:3]=c(NA,NA)
b=rep(2,10)
b[3:4]=c(NA,NA)
c=cbind(a,b)
md.pattern(c)
```
其中1表示该变量取值中无缺失值，0表示有缺失值。左侧数字表示对应行的数据样例的个数，如7表示a,b均无缺失值的样本个数为7个，以此类推

###相关性
cor()函数<br>
下面演示计算Insurance集中Holders和Claims两个变量的相关系数

```{r}
cor(Insurance$Holders,Insurance$Claims)
```

下面以rattle包中的weather数据集说明处理过程
```{r}
library(rattle)
data(weather)#获取数据集
str(weather)#查看数据集
#绘图之前，先计算得到相关系数矩阵
var=c(12:21)#设置所选12-21列的变量
cor_matrix=cor(weather[var],use="pairwise")#计算相关系数矩阵
cor_matrix#显示
```

下面用Ellipse包中的plotcorr()来绘图
```{r}
library(ellipse)
plotcorr(cor_matrix,col=rep(c("white","black"),5))#对如上相关系数矩阵画图
```
圆形宽窄表示相关性大小，越窄相关性越高，方向为相关性的正负。在plotorr()函数中加上参数type=lower则只显示下三角图（图是对称的，简洁）

#R语言编程艺术

##杂项
* &用于向量的逻辑运算，&&用于标量的逻辑运算。
* diff(data)用于求data[i]-data[9-1]
* 注意一个data.frame的数据类型，选择一行或者一列时会降维，加上drop=FALSE
* 对一个矩阵m，row(m)返回一个和矩阵一样维数的矩阵，元素为对应元素的行号，col()同理
* 查看数据类型：class(),typeof(),mode(),str()
* 查看一个对象的组件attributes()
* 取消名字：names(data) <- NULL
* 可用vector来创建列表：gg <- vector(mode="list")##创建一个空列表
* 删除列表元素可直接把其值设为NULL
* unlist(list)返回列表的元素(返回形式是一个向量，第一列为名字)
* 去掉一个向量的名字：data <- unname(data)
* 递归型列表和非递归型列表：
    * c(list(a=1,b=2,c=list(d=5,e=9)))#递归型列表
    * c(list(a=1,b=2,c=list(d=5,e=9)),recursive=T)#得到的实现向量
* complete.case(data.frame)#返回逻辑值，当一行数据都没有NA值时为TRUE
* assign(str,value)函数，它可以通过变量名字的字符串来赋值，又能设置变量为顶级变量
* CSV格式文件，检查每一条记录所包含字段的个数是否正确，count.fields(data,sep=","),可用all()来检查，all(count.fields(data,sep=",")==number)
* 检查字段是否有拼写错误：for(col in 1:ncol(data))print(unique(sort(data[,col])))
* lapply()函数和sapply()函数用于列表是对列表的每一个元素操作，用于data.frame是对每一列元素操作
* 对factor数据用unclass()返回一列向量，对应为数据的factor的真实值（一般是1,2,...,n,...）
* tapply(x,f,g)#其中x是向量，f是因子或因子列表，g是函数；其执行的操作是将x分组，每组对应一个因子水平，得到x的子向量，每个子向量应用函数g
* split(x,f)函数，这里x和f与tapply(x,f,g)中的意义相似，x为向量或数据框，f是因子或因子列表。该函数把x划分组，并返回分组的列表（x在split()中可以是数据框，而在tapply()中不可以）（x和f是对应的）
* by()函数，与tapply()的运作方式类似，但by()应用于对象而不仅是向量，第一个参数指定数据，第二个数据指定分组，第三个参数是用于每组的函数
* 提取名字：names(),colnames(),rownames(),dimnames()
* 对于table对象，subtable(table,list())可以提取字表，list()中之处横轴名字=c()，纵轴名字=c()，指明对于的水平，字符串表示
* do.call(f,argslist),其中f是一个函数，argslist是函数f()的参数列表
* 其他与因子有关的函数
    * aggregate(data,list(f),g)#data是数据，f是因子，g是函数
    * cut(x,b,labels=FALSE)#x是数据，b是一列数，对应组成左开右闭区间，返回对应数据落入的区间的index，
    * findInterval()

##第七章 R语言编程结构
* 7.1控制语句
    * 循环：for(),while(),repeat{}(其中repeat没有逻辑判断退出条件，必须利用break（或者类似return）的语句)
    * next，跳过本次迭代的剩余部分，直接进入循环的下一次迭代
    * 对读取文件循环：
```{r,eval=FALSE}
#循环读取 并打印每一个文件的内容
for(fn in c("file1","file2"))print(scan(fn))
```
    * 对非向量集合的循环：
        * lapply():如果循环的每次循环独立，可以以任意顺序执行
        * get()：这个函数接受一个代表对象名字的字符串参数，然后返回该对象的内容
    * 一个函数对象g,formals(g)返回其参数，body(g)返回函数体
    * 查看函数代码：可直接输入g，或用函数page(g)，还可以edit(g)
    * formuals()和body()可以当做参数使用，如body(g) <- quote(x+1),改变函数g的功能
    
* 7.6 环境和变量作用域的问题
    * R语言中，函数正式的被称为“闭包”（closure）。函数不仅包括参数和函数体，还包括“环境”（environment）
    1. 顶层环境
        * environment(object)可查看对象所处的环境，返回的是对象定义的所处的环境
        * ls()会把某个环境中的所有对象列举出来，如果在顶层调用，就会得到顶层环境下的对象名单，ls.str()可以获得更多信息
    2. 变量作用于的层次全局变量和局部变量是相对的，要看相对于哪个变量来说
        * 函数体内可以直接调用上一层环境的变量。R语言解释器在局部变量中没有找到，就会在更高层次里查找，一直往上寻找
        * 在层次中发生命名冲突是可以的。冲突时优先使用最里层的变量
    3. 关于ls()的进一步讨论
        * print(ls(evvir=parent.frame(n=1))),在parent.frame()中，参数n设定了要沿函数调用向上追溯几个框架。此时第0层框架依赖于执行时所在的环境
    4. 函数（几乎）没有副作用
        * 函数不会改变非局部变量。代码可以给这些变量重新赋值，但实际上这种行为只会影响他们的备份，而不是变量本身。
    8. 向上级层次进行写操作
        * 在当前层次使用超赋值运算符<<-,或者使用函数assign()。
        * 超赋值<<-运算符的写操作，会导致对上级环境层次的查找，直到遇到含该变量的第一个层次。如果没有找到，就会选取全局层次
        * assign("u",2-u,pos=.GlobalEnv)#assign()函数让R把2-u（此处u是局部变量）的值向上赋值给调用栈中的变量u，具体而言是顶层环境下的u。

* 7.11 写函数代码的工具
    2. edit()函数
        * 想修f1()函数：edit(f1)
        * 创建一个非常类似与f1()的函数f2()：f2 <- edit(f1),这样就提供了一份拷贝。可以在它的基础上进行修改并保存到f2()上

* 7.12 创建自己的二元运算符
```{r,eval=FALSE}
"%a2b%" <- function(a,b)return(a+2*b)
3 %a2b% 5
```

* 7.13 匿名函数
    * 在调apply()函数时使用一个匿名函数：apply(z,1,function(x) x/c(2,8))

##第八章 数学运算与模拟
* 8.1 数学函数
    * 一些内置函数
        * exp():以自然常数e为底的指数函数
        * log():自然对数
        * log10():以10为底的常用对数
        * sqrt():平方根
        * abs():绝对值
        * sin(),cos()等：三角函数
        * 