---
title: "Sundry"
author: "jsysley_mac"
date: "2016年9月18日"
output: html_document
---

三个数据集：<br>
```{r}
#自带数据集
str(women)
str(uspop)
str(Titanic)
```

---

##names(),class(),head(),tail()
```{r}
library(MASS)
data("Insurance")#获取数据集
str(Insurance)#查看数据集
names(Insurance)#查看数据集的变量名字
head(names(Insurance),n=2)#仅列出前面两个变量名字
tail(names(Insurance),n=2)#仅列出后面两个变量名字
head(Insurance$Holders,n=2)#仅列出前面两个数据
```

---

###通过系列函数as.numeric(),as.integer(),as.logical(),as.character()
强制数据转换

---

###通过系列函数is.numeric(),is.integer(),is.logical(),is.character()来判断数据类型，返回布尔值

---

#数据抽样
用到base软件包的sample()函数，以及sampling包的strata(),cluster()函数

###简单随机抽样：sample()
sample(x,size,replace=FALSE,prob=NULL)<br>
* 其中x表示带抽取对象，一般用向量表示；size为非负整数，抽取的样本个数，replace表示是否为有放回抽样，prob设置抽取各样本的概率，默认等概率

例如对于一个数据集Insurance，可以如下方式抽样：
```{r}
str(Insurance)
sub1=sample(nrow(Insurance),10,replace = TRUE)#抽取index来获取样本
sub2=Insurance[sub1,]#通过index获取样本
```

下面演示用prob时向量怎么写，最后一条样本概率为1，其他样本概率为0
```{r}
sub3=sample(nrow(Insurance),10,replace = TRUE,prob = c(rep(0,nrow(Insurance)-1),1))#prob的向量长度要注意

sub4=Insurance[sub3,]#抽取数据
```

---

---

###分层抽样：strata()
strata(data,stratanames=NULL,size,method=c("srswor","srswr","poission","systematic",pik,description=FALSE))
* 其中，data为待抽数据集；stratanames中为分层所依据的变量名称；size为抽取的各层的样本数（顺序与数据集改变量的水平出现顺序一致；method为抽样方法，分别为无放回，有放回，泊松，系统抽样，默认srswor；pik设置各层中各样本的概率；description选择是否输出含有各层基本信息的结果）

下面对数据集Insurance按照District变量为分层变量来抽样，1-4个街区分别抽取1-4个样本

```{r}
library(sampling)
sub5=strata(Insurance,stratanames="District",size=c(1,2,3,4),method="srswor")
sub5
#其中第一列为样本所在数据集的行号，最后一列为所在层数，Prob为所在层数的抽样概率
#通过getdata()函数获取分层抽样的数据
getdata(Insurance,sub5)
```

---

###整群抽样：cluster()
cluster(data,clustername,size,method=c("srswor","srswr","poisson","systematic"),pik,description=FALSE)
* 其中，data为待抽数据集；size为抽取的样本数；method为抽样方法，分别为无放回，有放回，泊松，系统抽样，默认srswor；pik设置各层中各样本的概率；description选择是否输出含有各层基本信息的结果）；clustername指定用来划分群的变量名称

```{r}
str(Insurance)
#共抽取2个整群，所含样本数为32个
sub6=cluster(Insurance,clustername = "District",size = 2,method = "srswor",description = TRUE)
#显示抽样结果,抽中的District取值为2，3的两个整群，共四个群，每个群抽中的概率0.5
sub6
#拿到数据
getdata(Insurance,sub6)
```

---

###划分训练集与测试集
以Insurance数据集为例，无放回方式抽取3/4的样本作为训练集，剩下1/4为测试集

```{r}
train_sub=sample(nrow(Insurance),3/4*nrow(Insurance))#抽取行号
train_data=Insurance[train_sub,]#拿取数据作为训练集
test_data=Insurance[-train_sub,]#拿取剩下的数据作为测试集
```


#探索性数据分析

用到Hmisc()包：describe()

fBasics包的basicStats()

timeDate包的skewness(),kurtosis()



###变量概况
```{r}
attributes(Insurance)#查看数据属性列表
str(Insurance)#查看数据集结构
names(Insurance)#列出数据集的各个变量的名字
summary(Insurance)#查看数据集各变量的一系列统计指标值
```

用Hmisc包的describe()函数查看变量概况，会给出样本总个数(n)，缺失样本数(missing)，水平个数(unique)

```{r}
library(Hmisc)
describe(Insurance)
```

```{r}
library(fBasics)
basicStats(Insurance$Holders)
```

计算峰度和偏度，这两个指标值可以通过basicStats()函数得到，也可以用以下方法得到
```{r}
library(timeDate)
skewness(Insurance[,4:5])#计算偏度
kurtosis(Insurance[,4:5])#计算峰度
```

#####稀疏性
用Matrix包来探究，为R中最著名的稀疏矩阵包，其提供的函数主要用于处理高密度矩阵或者稀疏矩阵

下面生产一个10*10的数据矩阵，100个元素，只有10个元素随机取1
```{r}
library(Matrix)
i=sample(1:10,10,replace = TRUE)#在1到10有放回取10个数，作为数据集中非空元素的行号
j=sample(1:10,10,replace=TRUE)#在1到10中有放回的取10个数，作为数据集中非空元素的列���号
(A=sparseMatrix(i,j,x=1))#对i行j列的元素取值1，其余为空,生成稀疏矩阵A
```

#####缺失值观察
用mice包的md.pattern()函数来获取其中的缺失值得分布情况

```{r}
library(mice)
a=rep(1,10)
a[2:3]=c(NA,NA)
b=rep(2,10)
b[3:4]=c(NA,NA)
c=cbind(a,b)
md.pattern(c)
```
其中1表示该变量取值中无缺失值，0表示有缺失值。左侧数字表示对应行的数据样例的个数，如7表示a,b均无缺失值的样本个数为7个，以此类推


#####相关性
cor()函数<br>
下面演示计算Insurance集中Holders和Claims两个变量的相关系数

```{r}
cor(Insurance$Holders,Insurance$Claims)
```

下面以rattle包中的weather数据集说明处理过程
```{r}
library(rattle)
data(weather)#获取数据集
str(weather)#查看数据集
#绘图之前，先计算得到相关系数矩阵
var=c(12:21)#设置所选12-21列的变量
cor_matrix=cor(weather[var],use="pairwise")#计算相关系数矩阵
cor_matrix#显示
```

下面用Ellipse包中的plotcorr()来绘图
```{r}
library(ellipse)
plotcorr(cor_matrix,col=rep(c("white","black"),5))#对如上相关系数矩阵画图
```
圆形宽窄表示相关性大小，越窄相关性越高，方向为相关性的正负。在plotorr()函数中加上参数type=lower则只显示下三角图（图是对称的，简洁）

#画图

####直方图
```{r}
hist(Insurance$Claims,freq = F,density = 20,main="Histogram of Density of Insurance$Claims")#设定dreq和density参数
lines(density(Insurance$Claims))#在直方图中添加概率密度曲线
```

---

####累积分布图
用Himsc包中的Ecdf()函数
```{r}
library(Hmisc)
Ecdf(Insurance$Claims,xlab="Claims",main="Cumulative Distribution of Claims")#绘制Claims变量的累积分布图
```


####箱线图
```{r}
Claims_bp=boxplot(Insurance$Claims,main="Distribution of Claims")#对Claims变量绘制箱线图
Claims_bp$stats#获取箱线图的5个界限值
points(x=1,y=mean(Insurance$Claims),pch=8)#用星号标出均值的位置
Claims_points=as.matrix(Insurance$Claims[which(Insurance$Claims>102)],6,1)#获取超出上册延展线的6个异常值,组成6*1矩阵
```

####条形图
```{r}
barplot(Insurance$Claims)
```

####点阵图
```{r}
dotchart(Insurance$Claims)
```

####饼图
pie(Insurance$Claims)


#数据预处理
用mice包的数据集
```{r}
library(mice)
```

用nhanes2数据集演示数据清理，该数据集含有缺失值的小规模数据
```{r}
str(nhanes2)#查看数据属性
library(mice)
md.pattern(nhanes2)#查看缺失值，还有诸如describe()，summary()函数可以用
head(nhanes2)#直观了解数据
```

计算nhanes2中缺失值的数量
```{r}
sum(is.na(nhanes2))
```

函数complete.cases()用来判断某一观测样本是否完整,下面计算nhanes2中完整样本的数量
```{r}
sum(complete.cases(nhanes2))
```

结果显示数据中共有27个缺失值，数据框13条完整观测数据，12条观测值存在缺失值

下面用mice包中的md.pattern()函数查看缺失值分布情况
```{r}
library(mice)
md.pattern(nhanes2)
```

##缺失值处理的一直方法：多重插补法
通过变量间的关系对缺失数据进行预测，利用蒙特卡洛方法生成多个完整的数据集，再对这些数据集分别进行分析，最后对分析结果进行汇总处理

在R中通过mice包中的mice()函数进行处理

mice(data,m=5,...)
* 其中，data代表有一个缺失值的数据框或矩阵，缺失值用NA表示；m表示插补重数，即生成m个完整数据集，默认值m=5

下面以数据集nhanes2数据集演示,以chl为因变量，age,hyp,bmi为自变量，构建回归模型，由于数据中存在缺失值，通过以下方式构建：

```{r}
library(mice)
str(nhanes2)

imp=mice(nhanes2,m=4)#生成4组完整的数据库并给imp
fit=with(imp,lm(chl~age+hyp+bmi))#生成线性回归模型
pooled=pool(fit)#对建立的4个模型进行汇总
summary(pooled)
```
其中nmis表示了变量中的缺失数据个数，fmi表示由缺失数据贡献的变异

##对缺失值判断后，如何处理

###删除法
* 删除观测样本
* 删除变量
* 使用完整原始数据分析
* 改变权重

###插补法（均值插补，回归插补，二阶插补，热平台，冷平台，抽样填补）

#####从总体中抽取某个样本代替缺失样本

```{r}
sub=which(is.na(nhanes2[,4])==TRUE)#返回nhanes2数据集中第4列为NA的行的行号
dataTR=nhanes2[-sub,]#将第4列不为NA的数据存入数据集dataTR中
dataTE=nhanes2[sub,]#将第4列为NA的数据存入数据集dataTE中
dataTE[,4]=sample(dataTR[,4],length(dataTE[,4]),replace = TRUE)#在非缺失值中简单抽样填充缺失值
dataTE#第4列数据已经没有NA
```

####均值法
* 均值法是计算缺失值所在变量的所有非缺失值的均值，用均值来代替插补方法，类似的还可以用中位数等各种统计量来插补，下面演示均值法

```{r}
sub=which(is.na(nhanes2[,4])==TRUE)#返回nhanes2数据集中第3列为NA的行
dataTR=nhanes2[-sub,]#将第4列不为NA的数据存入数据集dataTR中
dataTE=nhanes2[sub,]#将第4列为NA的数据存入数据集dataTE中
dataTE[,4]=mean(dataTR[,4])#用非缺失值的均值代替缺失值
dataTE
```

####回归法
回归模型将需要插补变量作为因变量，其他变量作为自变量，通过建立回归模型预测出因变量的值对缺失值进行插补

```{r}
sub=which(is.na(nhanes2[,4])==TRUE)#返回nhanes2数据集中第3列为NA的行
dataTR=nhanes2[-sub,]#将第4列不为NA的数据存入数据集dataTR中
dataTE=nhanes2[sub,]#将第4列为NA的数据存入数据集dataTE中
dataTE
#下面进行回归
lm1=lm(chl~age,data = dataTR)
dataTE[,4]=round(predict(lm1,dataTE))
dataTE
```

####热平台
在非缺失数据集中找到一个与缺失值所在样本相似的样本(匹配样本)，利用其中的观察值对缺失值进行插补

```{r}
accept=nhanes2[which(apply(is.na(nhanes2),1,sum)!=0),]#取出存在缺失值的样本,1表示对行，apply对行求和，取出缺失值个数不为0的样本
donate=nhanes2[which(apply(is.na(nhanes2),1,sum)==0),]#无缺失值的样本
```
以上将nhanes2数据集分层有缺失值和无缺失值两个样本，分别存在accept，donate中

一下对accept中的第二个样本插补：

```{r}
accept[2,]
sa=donate[which(donate[,1]==accept[2,1]&donate[,3]==accept[2,3]&donate[,4]==accept[2,4]),]#将缺失的数据小项分别比对，找出相似样本
sa#发现存在
accept[2,2]=sa[1,2]#缺失值插补
accept[2,]
```

####冷平台
实际中，当变量个数很多，难以找到相似样本，此时可以按照某些变量将数据分层，在层中对缺失值使用均值插补，即冷平台方法

```{r}
level1=nhanes2[which(nhanes2[,3]=="yes"),]#按变量hyp分层
level1
level1[4,4]=mean(level1[1:3,4])#用层内均值代替第4个样本
level1
```

##噪声数据处理
* 用outliers包的outlier()函数寻找噪声数据，该函数通过寻找数据集中与其他观测值以均值差距最大的点作为异常值

outlier(x,opposite=FALSE,logical=FALSE)
* 其中，x是一个数据（同常是向量），若x是数据框或矩阵，则函数逐列计算；opposite可输入TRUE时给出相反值（如果最大值与均值差异最大，则给出最小值）；logical为TRUE时，给向量赋予逻辑值，可能出现噪声的位置用TRUE表示
```{r}
library(outliers)
#设置随机数种子，保证每次出现的随机数相同
set.seed(1)
s1=.Random.seed

y=rnorm(100)#生成1--个标准正太随机数
outlier(y)#找出离群最远的值
outlier(y,opposite = TRUE)#找出离群值相反的值
dotchart(y)

dim(y) <- c(20,5)#将y数据划分成20行5列的数据
outlier(y)#求矩阵中每列离群最远值

set.seed(1)
s1=.Random.seed
y=rnorm(10)
outlier(y,logical = TRUE)#返回相应逻辑值，离群最远值用TRUE标记
plot(y)
```


